
name: CI

on:
  push:
    branches:
      - master
  pull_request:
  release:
    types: published

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    
      - name: checkout
        uses: actions/checkout@v1

      - name: extract version base
        id: extract_version_base
        shell: pwsh
        run: |
          $mm = Test-ModuleManifest -Path ./GitHubActions/GitHubActions.psd1
          $mv = $mm.Version
          Write-Output "Got module manifest version: $mv"

          $versionBase = "$($mv.Major).$($mv.Minor).$($mv.Build)"
          Write-Output "Computed version base: $versionBase"
          Write-Host "::set-output name=version_base::$versionBase"
          Write-Host "::set-env name=VERSION_BASE::$versionBase"

      - name: compute build nums
        uses: zyborg/gh-action-buildnum@v1
        with:
          gist_token: ${{ secrets.GIST_TOKEN }}
          version_key: ${{ steps.extract_version_base.outputs.version_base }}
          set_env: true

      - name: update version build
        shell: pwsh
        run: |
          $versBase = $env:VERSION_BASE
          $buildNum = $env:BUILDNUM_FOR_VERSION
          $versFull = "$($versBase).$($buildNum)"

          Write-Output "Computed full version: $versFull"
          Update-ModuleManifest -Path ./GitHubActions/GitHubActions.psd1 -ModuleVersion $versFull

          ## Pull it back out to verify it was updated
          $mm = Test-ModuleManifest -Path ./GitHubActions/GitHubActions.psd1
          Write-Output "Updated module manifest with version: $($mm.Version)"

      - name: pester tests
        shell: pwsh
        run: |
          $modulesToInstall = @(
            'Pester'
            'functional'
          )
          $modulesToInstall | ForEach-Object {
            if (-not (Get-Module -ListAvailable $_)) {
              Write-Output "Module [$_] not found, INSTALLING..."
              Install-Module $_ -Force
            }
          }

          Import-Module Pester

          Invoke-Pester -Path ./tests/GitHubActions_tests.ps1 -ErrorVariable pesterErrs1
          Invoke-Pester -Path ./tests/GitHubActions-context_tests.ps1 -ErrorVariable pesterErrs2

          if ($pesterErrs1 -or $pesterErrs2) {
            throw "Failed Pester tests found"
          }

      - name: publish to myget
        shell: pwsh
        env:
          MYGET_NUGET_API_KEY: ${{ secrets.MYGET_NUGET_API_KEY }}
        run: |
          $nugetApiKey   = $env:MYGET_NUGET_API_KEY
          $nugetApiKeySS = ConvertTo-SecureString $nugetApiKey -AsPlainText
          $nugetCred     = [pscredential]::new('ignored', $nugetApiKeySS)
          Register-PSRepository -Name myget -Credential $nugetCred `
            -SourceLocation https://www.myget.org/F/pwsh-github-action-tools/api/v2 `
            -PublishLocation https://www.myget.org/F/pwsh-github-action-tools/api/v2/package
          
          Publish-Module -Path ./GitHubActions -Repository myget -NuGetApiKey $nugetApiKey

      - name: upload artifact
        #if: startsWith(github.ref, 'refs/tags/v=')
        if: github.event_name == 'release'
        uses: actions/upload-artifact@v1
        with:
          name: GitHubActions
          path: ./GitHubActions

  publish:
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'release'
    
    steps:

      - name: download distributable artifact
        uses: actions/download-artifact@v1
        with:
          name: GitHubActions
      
      - name: bundle distributable components
        shell: pwsh
        run: |
          cd GitHubActions
          Compress-Archive -DestinationPath ../GitHubActions.zip -Path ./*

      - name: publish to myget
        shell: pwsh
        env:
          PSGALLERY_NUGET_API_KEY: ${{ secrets.PSGALLERY_NUGET_API_KEY }}
        run: |
          $nugetApiKey   = $env:PSGALLERY_NUGET_API_KEY
          Publish-Module -Path ./GitHubActions -NuGetApiKey $nugetApiKey

      - name: attach asset to release
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $tagName = $env:GITHUB_REF -replace 'refs/tags/',''
          $githubHeaders = @{ Authorization = "token $($env:GITHUB_TOKEN)" }
          $githubRepo = $env:GITHUB_REPOSITORY
          $listRelsUrl = "https://api.github.com/repos/$($githubRepo)/releases"
          $listRelsResp = Invoke-WebRequest -Headers $githubHeaders $listRelsUrl
          
          $listRels = $listRelsResp.Content | ConvertFrom-Json
          if (-not ($listRels.Count)) {
            throw "list releases response did not resolve to any releases"
          }
          else {
            Write-Output "Found [$($listRels.Count)] release(s)."
          }
          $thisRel = $listRels | Where-Object { $_.tag_name -eq $tagName }
          if (-not $thisRel) {
            throw "could not find release for tag [$tagName]"
          }
          else {
            Write-Output "Found release [$($thisRel.tag_name)][$($thisRel.url)]"
          }
          $uploadUrl = $thisRel.upload_url.Replace(
            '{?name,label}','?name=GitHubActions.zip')
          $uploadHeaders = @{
            "Authorization" = "token $($env:GITHUB_TOKEN)"
            "Content-Type" = "application/zip"
          }
          Write-Output "Adding asset to [$uploadUrl]"
          $uploadResp = Invoke-WebRequest -Headers $uploadHeaders $uploadUrl `
            -InFile GitHubActions.zip
