
name: CI

on:
  push:
    branches:
      - master
      - pester-test-report
  pull_request:
  release:
    types: published

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    
      - name: checkout
        uses: actions/checkout@v1

      - name: extract version base
        id: extract_version_base
        shell: pwsh
        run: |
          $mm = Test-ModuleManifest -Path ./GitHubActions/GitHubActions.psd1
          $mv = $mm.Version
          Write-Output "Got module manifest version: $mv"

          $versionBase = "$($mv.Major).$($mv.Minor).$($mv.Build)"
          Write-Output "Computed version base: $versionBase"
          Write-Host "::set-output name=version_base::$versionBase"
          Write-Host "::set-env name=VERSION_BASE::$versionBase"

      - name: compute build nums
        uses: zyborg/gh-action-buildnum@v1
        with:
          gist_token: ${{ secrets.GIST_TOKEN }}
          version_key: ${{ steps.extract_version_base.outputs.version_base }}
          set_env: true

      - name: update version build
        shell: pwsh
        run: |
          $versBase = $env:VERSION_BASE
          $buildNum = $env:BUILDNUM_FOR_VERSION
          $versFull = "$($versBase).$($buildNum)"

          Write-Output "Computed full version: $versFull"
          Update-ModuleManifest -Path ./GitHubActions/GitHubActions.psd1 -ModuleVersion $versFull

          ## Pull it back out to verify it was updated
          $mm = Test-ModuleManifest -Path ./GitHubActions/GitHubActions.psd1
          Write-Output "Updated module manifest with version: $($mm.Version)"

      - name: pester tests
        shell: pwsh
        run: |
          $modulesToInstall = @(
            'Pester'
            'functional'
          )
          $modulesToInstall | ForEach-Object {
            if (-not (Get-Module -ListAvailable $_)) {
              Write-Output "Module [$_] not found, INSTALLING..."
              Install-Module $_ -Force
            }
          }

          Import-Module Pester

          Invoke-Pester -Path ./tests/GitHubActions_tests.ps1 -ErrorVariable pesterErrs1
          Invoke-Pester -Path ./tests/GitHubActions-context_tests.ps1 -ErrorVariable pesterErrs2

      - name: pester tests reports
        if: ${{ !cancelled() }}
        continue-on-error: true
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          Import-Module Pester
          Import-Module ./GitHubActions

          if (-not (Test-Path ./_IGNORE)) {
            mkdir ./_IGNORE
          }
          Invoke-Pester -Path ./tests/GitHubActions_tests.ps1 -ErrorVariable pesterErrs1 `
              -OutputFile ./_IGNORE/GitHubActions_tests.xml
          Invoke-Pester -Path ./tests/GitHubActions-context_tests.ps1 -ErrorVariable pesterErrs2 `
              -OutputFile ./_IGNORE/GitHubActions-context_tests.xml

          ./tools/test-report/nunitxml2md.ps1 -Verbose -xmlFile ./_IGNORE/GitHubActions_tests.xml
          ./tools/test-report/nunitxml2md.ps1 -Verbose -xmlFile ./_IGNORE/GitHubActions-context_tests.xml
          $reportData1 = [System.IO.File]::ReadAllText("$PWD/./_IGNORE/GitHubActions_tests.md")
          $reportData2 = [System.IO.File]::ReadAllText("$PWD/./_IGNORE/GitHubActions-context_tests.md")

          ## Publishing in GH Workflow

          $ghToken = $env:GITHUB_TOKEN
          $ctx = Get-ActionContext
          $repo = Get-ActionRepo

          Write-ActionInfo "Resolving REF"
          $ref = $ctx.Sha
          if ($ctx.EventName -eq 'pull_request') {
              Write-ActionInfo "Resolving PR REF"
              $ref = $ctx.Payload.pull_request.head.sha
              if (-not $ref) {
                  Write-ActionInfo "Resolving PR REF as AFTER"
                  $ref = $ctx.Payload.after
              }
          }
          if (-not $ref) {
              Write-ActionError "Failed to resolve REF"
              exit 1
          }

          Write-ActionInfo "Adding Check Run"
          $url = 'https://api.github.com/repos/PKISharp/ACMESharpCore/check-runs'
          $hdr = @{
              Accept = 'application/vnd.github.antiope-preview+json'
              Authorization = "token $ghToken"
          }
          $bdy = @{
            name       = 'TESTS: GitHubActions_tests'
            head_sha   = $ref
            status     = 'completed'
            conclusion = 'neutral'
            output     = @{
                title   = 'Test Run:  GitHubActions_tests'
                summary = 'This run completed at `${[datetime]::Now}`'
                text    = $reportData1
            }
          }
          Invoke-WebRequest -Headers $hdr $url -Method Post -Body ($bdy | ConvertTo-Json)
          $bdy.name = 'TESTS: GitHubActions-context_tests'
          $bdy.output.title = 'Test Run:  GitHubActions-context_tests'
          $bdy.output.text = $reportData2
          Invoke-WebRequest -Headers $hdr $url -Method Post -Body ($bdy | ConvertTo-Json)

      - name: publish to myget
        shell: pwsh
        env:
          MYGET_NUGET_API_KEY: ${{ secrets.MYGET_NUGET_API_KEY }}
        run: |
          $nugetApiKey   = $env:MYGET_NUGET_API_KEY
          $nugetApiKeySS = ConvertTo-SecureString $nugetApiKey -AsPlainText
          $nugetCred     = [pscredential]::new('ignored', $nugetApiKeySS)
          Register-PSRepository -Name myget -Credential $nugetCred `
            -SourceLocation https://www.myget.org/F/pwsh-github-action-tools/api/v2 `
            -PublishLocation https://www.myget.org/F/pwsh-github-action-tools/api/v2/package
          
          Publish-Module -Path ./GitHubActions -Repository myget -NuGetApiKey $nugetApiKey

      - name: upload artifact
        #if: startsWith(github.ref, 'refs/tags/v=')
        if: github.event_name == 'release'
        uses: actions/upload-artifact@v1
        with:
          name: GitHubActions
          path: ./GitHubActions

  publish:
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'release'
    
    steps:

      - name: download distributable artifact
        uses: actions/download-artifact@v1
        with:
          name: GitHubActions
      
      - name: bundle distributable components
        shell: pwsh
        run: |
          cd GitHubActions
          Compress-Archive -DestinationPath ../GitHubActions.zip -Path ./*

      - name: publish to powershell gallery
        shell: pwsh
        env:
          PSGALLERY_NUGET_API_KEY: ${{ secrets.PSGALLERY_NUGET_API_KEY }}
        run: |
          $nugetApiKey   = $env:PSGALLERY_NUGET_API_KEY
          Publish-Module -Path ./GitHubActions -NuGetApiKey $nugetApiKey

      - name: attach asset to release
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $tagName = $env:GITHUB_REF -replace 'refs/tags/',''
          $githubHeaders = @{ Authorization = "token $($env:GITHUB_TOKEN)" }
          $githubRepo = $env:GITHUB_REPOSITORY
          $listRelsUrl = "https://api.github.com/repos/$($githubRepo)/releases"
          $listRelsResp = Invoke-WebRequest -Headers $githubHeaders $listRelsUrl
          
          $listRels = $listRelsResp.Content | ConvertFrom-Json
          if (-not ($listRels.Count)) {
            throw "list releases response did not resolve to any releases"
          }
          else {
            Write-Output "Found [$($listRels.Count)] release(s)."
          }
          $thisRel = $listRels | Where-Object { $_.tag_name -eq $tagName }
          if (-not $thisRel) {
            throw "could not find release for tag [$tagName]"
          }
          else {
            Write-Output "Found release [$($thisRel.tag_name)][$($thisRel.url)]"
          }
          $uploadUrl = $thisRel.upload_url.Replace(
            '{?name,label}','?name=GitHubActions.zip')
          $uploadHeaders = @{
            "Authorization" = "token $($env:GITHUB_TOKEN)"
            "Content-Type" = "application/zip"
          }
          Write-Output "Adding asset to [$uploadUrl]"
          $uploadResp = Invoke-WebRequest -Headers $uploadHeaders $uploadUrl `
            -InFile GitHubActions.zip
